local GameModule = {}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local player = Players.LocalPlayer

-- Mining variables
local RocksMainFolder = workspace.Rocks
GameModule.MiningSpeed = 50
GameModule.OreTeleportOffset = 5
GameModule.EnableAntiStuck = true
GameModule.StuckCheckDelay = 3
GameModule.SelectedOreType = "Pebble"

local CurrentTarget = nil
local IsAutoFarming = false
local SkippedOres = {}
local MiningHeartbeatConnection = nil
local MiningNoclipConnection = nil

-- Combat variables
local LivingFolder = workspace.Living
GameModule.MoveSpeed = 25
GameModule.MobTeleportOffset = 15
GameModule.CombatEnableAntiStuck = true
GameModule.CombatStuckCheckDelay = 3
GameModule.SelectedMobType = "Zombie"

local CombatCurrentTarget = nil
local IsAutoAttacking = false
local SkippedMobs = {}
local HeartbeatConnection = nil
local NoclipConnection = nil

-- Potion variables
local PotionConnection = nil
GameModule.AutoUsePotions = {
	Damage = false,
	Speed = false,
	Health = false,
	Miner = false,
	Luck = false
}

local ROCK_FOLDERS = {
	"Island1CaveStart",
	"Island1CaveMid",
	"Island1CaveDeep",
	"Island2CaveStart",
	"Island2CaveMid",
	"Island2CaveDeep",
	"Island2CaveLavaClosed",
	"Island2CaveDangerClosed",
	"Island2CaveDanger1",
	"Island2CaveDanger2",
	"Island2CaveDanger3",
	"Island2CaveDanger4",
}

GameModule.MobTypes = {
	"Zombie", "Elite Zombie", "Delver Zombie", "Brute Zombie",
	"Bomber", "Skeleton Rogue", "Axe Skeleton", "Deathaxe Skeleton",
	"Elite Rogue Skeleton", "Elite Deathaxe Skeleton", "Blight Pyromancer",
	"Reaper", "Slime", "Blazing Slime"
}

-- Helper Functions
local function equipTool(toolName)
	local backpack = player:WaitForChild("Backpack")
	local character = player.Character
	
	if not character then return false end
	
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid then return false end
	
	local equippedTool = character:FindFirstChild(toolName)
	if equippedTool and equippedTool:IsA("Tool") then
		return true
	end
	
	local tool = backpack:FindFirstChild(toolName)
	
	if tool and tool:IsA("Tool") then
		humanoid:UnequipTools()
		task.wait(0.1)
		humanoid:EquipTool(tool)
		return true
	end
	
	return false
end

local function swingPickaxe()
	local args = {
		[1] = "Pickaxe"
	}
	game:GetService("ReplicatedStorage"):WaitForChild("Shared", 9e9):WaitForChild("Packages", 9e9):WaitForChild("Knit", 9e9):WaitForChild("Services", 9e9):WaitForChild("ToolService", 9e9):WaitForChild("RF", 9e9):WaitForChild("ToolActivated", 9e9):InvokeServer(unpack(args))
end

local function attackMob()
	pcall(function()
		local args = {
			[1] = "Weapon"
		}
		game:GetService("ReplicatedStorage"):WaitForChild("Shared", 9e9):WaitForChild("Packages", 9e9):WaitForChild("Knit", 9e9):WaitForChild("Services", 9e9):WaitForChild("ToolService", 9e9):WaitForChild("RF", 9e9):WaitForChild("ToolActivated", 9e9):InvokeServer(unpack(args))
	end)
end

local function usePotion(potionName)
	pcall(function()
		local args = {
			[1] = potionName
		}
		game:GetService("ReplicatedStorage"):WaitForChild("Shared", 9e9):WaitForChild("Packages", 9e9):WaitForChild("Knit", 9e9):WaitForChild("Services", 9e9):WaitForChild("ToolService", 9e9):WaitForChild("RF", 9e9):WaitForChild("ToolActivated", 9e9):InvokeServer(unpack(args))
	end)
end

local function getOreInfo(ore)
	local info = {
		name = "Unknown",
		hp = "N/A",
		maxHP = "N/A",
		level = "N/A",
		currentHP = 0
	}
	
	local infoFrame = ore:FindFirstChild("infoFrame")
	if infoFrame then
		local frame = infoFrame:FindFirstChild("Frame")
		if frame then
			local rockName = frame:FindFirstChild("rockName")
			if rockName then
				info.name = rockName.Text or "Unknown"
			end
			
			local rockHP = frame:FindFirstChild("rockHP")
			if rockHP then
				local hpText = rockHP.Text or "N/A"
				info.hp = hpText
				local hpNum = tonumber(hpText:match("%d+"))
				if hpNum then
					info.currentHP = hpNum
				end
			end
			
			local lvl = frame:FindFirstChild("Lvl")
			if lvl then
				info.level = lvl.Text or "N/A"
			end
			
			local bb = frame:FindFirstChild("BB")
			if bb then
				local hpText = bb:FindFirstChild("rockHP")
				if hpText then
					info.maxHP = hpText.Text or "N/A"
				end
			end
		end
	end
	
	return info
end

local function getMobInfo(mob)
	local info = {
		name = mob.Name,
		currentHP = 0,
		maxHP = 100
	}
	
	local humanoid = mob:FindFirstChild("Humanoid")
	if humanoid then
		info.currentHP = humanoid.Health
		info.maxHP = humanoid.MaxHealth
	end
	
	local hrp = mob:FindFirstChild("HumanoidRootPart")
	if hrp then
		local infoFrame = hrp:FindFirstChild("infoFrame")
		if infoFrame then
			local frame = infoFrame:FindFirstChild("Frame")
			if frame then
				local rockName = frame:FindFirstChild("rockName")
				if rockName then
					info.name = rockName.Text or info.name
				end
				
				local rockHP = frame:FindFirstChild("rockHP")
				if rockHP then
					local hpText = rockHP.Text or "N/A"
					local hpNum = tonumber(hpText:match("%d+"))
					if hpNum then
						info.currentHP = hpNum
					end
				end
			end
		end
	end
	
	return info
end

local function isOreAlive(ore)
	if not ore or not ore.Parent then
		return false
	end
	
	local info = getOreInfo(ore)
	return info.currentHP > 0
end

local function isMobAlive(mob)
	if not mob or not mob.Parent then
		return false
	end
	
	local humanoid = mob:FindFirstChild("Humanoid")
	if not humanoid then
		return false
	end
	
	return humanoid.Health > 0
end

local function isOreSkipped(ore)
	return SkippedOres[ore] == true
end

local function isMobSkipped(mob)
	return SkippedMobs[mob] == true
end

local function markOreAsSkipped(ore)
	SkippedOres[ore] = true
end

local function markMobAsSkipped(mob)
	SkippedMobs[mob] = true
end

local function clearSkippedOres()
	SkippedOres = {}
end

local function clearSkippedMobs()
	SkippedMobs = {}
end

local function enableNoclip()
	local char = player.Character
	if not char then return end
	
	for _, part in pairs(char:GetDescendants()) do
		if part:IsA("BasePart") and part.CanCollide then
			part.CanCollide = false
		end
	end
end

local function findOreInObject(obj, oreType)
	local ore = obj:FindFirstChild(oreType)
	if ore then
		return ore
	end
	
	for _, child in pairs(obj:GetChildren()) do
		if child.Name == oreType or child:FindFirstChild(oreType) then
			local foundOre = child:FindFirstChild(oreType) or child
			if foundOre:FindFirstChild("Hitbox") and foundOre:FindFirstChild("infoFrame") then
				return foundOre
			end
		end
	end
	
	return nil
end

local function getNearestOre()
	local nearest = nil
	local shortestDist = math.huge
	
	local char = player.Character
	if not char then return nil end
	
	local hrp = char:FindFirstChild("HumanoidRootPart")
	if not hrp then return nil end
	
	for _, folderName in ipairs(ROCK_FOLDERS) do
		local folder = RocksMainFolder:FindFirstChild(folderName)
		
		if folder then
			for i, rock in ipairs(folder:GetChildren()) do
				if rock:IsA("Model") or rock:IsA("Part") or rock:IsA("Folder") then
					local ore = findOreInObject(rock, GameModule.SelectedOreType)
					
					if ore and isOreAlive(ore) and not isOreSkipped(ore) then
						local hitbox = ore:FindFirstChild("Hitbox")
						if hitbox then
							local dist = (hitbox.Position - hrp.Position).Magnitude
							if dist < shortestDist then
								shortestDist = dist
								nearest = {
									index = i,
									rock = rock,
									ore = ore,
									info = getOreInfo(ore),
									distance = dist,
									folder = folderName
								}
							end
						end
					end
				end
			end
		end
	end
	
	return nearest
end

local function getNearestMob()
	local nearest = nil
	local shortestDist = math.huge
	
	local char = player.Character
	if not char then return nil end
	
	local hrp = char:FindFirstChild("HumanoidRootPart")
	if not hrp then return nil end
	
	for _, mob in ipairs(LivingFolder:GetChildren()) do
		if mob:IsA("Model") and mob.Name:match(GameModule.SelectedMobType) then
			if isMobAlive(mob) and not isMobSkipped(mob) then
				local mobHrp = mob:FindFirstChild("HumanoidRootPart")
				if mobHrp then
					local dist = (hrp.Position - mobHrp.Position).Magnitude
					if dist < shortestDist then
						shortestDist = dist
						nearest = {
							mob = mob,
							info = getMobInfo(mob),
							distance = dist
						}
					end
				end
			end
		end
	end
	
	return nearest
end

local function moveToOre(oreData)
	if not oreData or not oreData.ore then return end
	
	local char = player.Character
	if not char then return end
	
	local hrp = char:FindFirstChild("HumanoidRootPart")
	if not hrp then return end
	
	local hitbox = oreData.ore:FindFirstChild("Hitbox")
	if not hitbox then return end
	
	local targetPosition = hitbox.Position + Vector3.new(0, GameModule.OreTeleportOffset, 0)
	local direction = (targetPosition - hrp.Position).Unit
	local distance = (targetPosition - hrp.Position).Magnitude
	
	enableNoclip()
	
	if distance > 2 then
		hrp.AssemblyLinearVelocity = direction * GameModule.MiningSpeed
		local lookDirection = (hitbox.Position - hrp.Position).Unit
		hrp.CFrame = CFrame.lookAt(hrp.Position, hrp.Position + lookDirection)
	else
		hrp.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
		local lookDirection = (hitbox.Position - hrp.Position).Unit
		hrp.CFrame = CFrame.lookAt(hrp.Position, hrp.Position + lookDirection)
	end
end

local function moveToMob(mobData)
	if not mobData or not mobData.mob then return end
	
	local char = player.Character
	if not char then return end
	
	local hrp = char:FindFirstChild("HumanoidRootPart")
	if not hrp then return end
	
	local mobRoot = mobData.mob:FindFirstChild("HumanoidRootPart")
	if not mobRoot then return end
	
	local targetPosition = mobRoot.Position + Vector3.new(0, GameModule.MobTeleportOffset, 0)
	local direction = (targetPosition - hrp.Position).Unit
	local distance = (targetPosition - hrp.Position).Magnitude
	
	enableNoclip()
	
	if distance > 2 then
		hrp.AssemblyLinearVelocity = direction * GameModule.MoveSpeed
		local lookDirection = (mobRoot.Position - hrp.Position).Unit
		hrp.CFrame = CFrame.lookAt(hrp.Position, hrp.Position + lookDirection)
	else
		hrp.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
		local lookDirection = (mobRoot.Position - hrp.Position).Unit
		hrp.CFrame = CFrame.lookAt(hrp.Position, hrp.Position + lookDirection)
	end
end

local function stopMiningMovement()
	if MiningHeartbeatConnection then
		MiningHeartbeatConnection:Disconnect()
		MiningHeartbeatConnection = nil
	end
	
	if MiningNoclipConnection then
		MiningNoclipConnection:Disconnect()
		MiningNoclipConnection = nil
	end
	
	local char = player.Character
	if char then
		local hrp = char:FindFirstChild("HumanoidRootPart")
		if hrp then
			hrp.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
		end
	end
	
	CurrentTarget = nil
end

local function stopCombatMovement()
	if HeartbeatConnection then
		HeartbeatConnection:Disconnect()
		HeartbeatConnection = nil
	end
	
	if NoclipConnection then
		NoclipConnection:Disconnect()
		NoclipConnection = nil
	end
	
	local char = player.Character
	if char then
		local hrp = char:FindFirstChild("HumanoidRootPart")
		if hrp then
			hrp.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
		end
	end
	
	CombatCurrentTarget = nil
end

-- Public Mining Functions
function GameModule.startAutoMining()
	IsAutoFarming = true
	equipTool("Pickaxe")
	
	task.wait(0.5)
	
	MiningNoclipConnection = RunService.Stepped:Connect(function()
		if IsAutoFarming then
			enableNoclip()
		end
	end)
	
	local lastHP = 0
	local stuckCheckTimer = 0
	
	MiningHeartbeatConnection = RunService.Heartbeat:Connect(function()
		if not IsAutoFarming then
			stopMiningMovement()
			return
		end
		
		if not CurrentTarget or not isOreAlive(CurrentTarget) then
			local nearestOre = getNearestOre()
			
			if nearestOre then
				CurrentTarget = nearestOre.ore
				lastHP = nearestOre.info.currentHP
				stuckCheckTimer = 0
			else
				clearSkippedOres()
				CurrentTarget = nil
				local char = player.Character
				if char then
					local hrp = char:FindFirstChild("HumanoidRootPart")
					if hrp then
						hrp.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
					end
				end
				return
			end
		end
		
		if CurrentTarget then
			moveToOre({ore = CurrentTarget})
			swingPickaxe()
			
			if GameModule.EnableAntiStuck then
				stuckCheckTimer = stuckCheckTimer + (1/60)
				
				if stuckCheckTimer >= GameModule.StuckCheckDelay then
					local currentInfo = getOreInfo(CurrentTarget)
					
					if currentInfo.currentHP == lastHP and currentInfo.currentHP > 0 then
						markOreAsSkipped(CurrentTarget)
						CurrentTarget = nil
					else
						lastHP = currentInfo.currentHP
					end
					
					stuckCheckTimer = 0
				end
			end
		end
	end)
end

function GameModule.stopAutoMining()
	IsAutoFarming = false
	stopMiningMovement()
end

function GameModule.clearSkippedOres()
	clearSkippedOres()
end

-- Public Combat Functions
function GameModule.startAutoAttack()
	IsAutoAttacking = true
	
	local weaponEquipped = false
	for _, toolName in ipairs({"Sword", "Bow", "Gun"}) do
		if equipTool(toolName) then
			weaponEquipped = true
			break
		end
	end
	
	task.wait(0.5)
	
	NoclipConnection = RunService.Stepped:Connect(function()
		if IsAutoAttacking then
			enableNoclip()
		end
	end)
	
	local lastHP = 0
	local stuckCheckTimer = 0
	
	HeartbeatConnection = RunService.Heartbeat:Connect(function()
		if not IsAutoAttacking then
			stopCombatMovement()
			return
		end
		
		if not CombatCurrentTarget or not isMobAlive(CombatCurrentTarget.mob) then
			local nearestMob = getNearestMob()
			
			if nearestMob then
				CombatCurrentTarget = nearestMob
				lastHP = nearestMob.info.currentHP
				stuckCheckTimer = 0
			else
				clearSkippedMobs()
				CombatCurrentTarget = nil
				local char = player.Character
				if char then
					local hrp = char:FindFirstChild("HumanoidRootPart")
					if hrp then
						hrp.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
					end
				end
				return
			end
		end
		
		if CombatCurrentTarget then
			moveToMob(CombatCurrentTarget)
			attackMob()
			
			if GameModule.CombatEnableAntiStuck then
				stuckCheckTimer = stuckCheckTimer + (1/60)
				
				if stuckCheckTimer >= GameModule.CombatStuckCheckDelay then
					local currentInfo = getMobInfo(CombatCurrentTarget.mob)
					
					if currentInfo.currentHP == lastHP and currentInfo.currentHP > 0 then
						markMobAsSkipped(CombatCurrentTarget.mob)
						CombatCurrentTarget = nil
					else
						lastHP = currentInfo.currentHP
					end
					
					stuckCheckTimer = 0
				end
			end
		end
	end)
end

function GameModule.stopAutoAttack()
	IsAutoAttacking = false
	stopCombatMovement()
end

function GameModule.clearSkippedMobs()
	clearSkippedMobs()
end

-- Public Potion Functions
function GameModule.startAutoPotions()
	if PotionConnection then
		PotionConnection:Disconnect()
	end
	
	PotionConnection = RunService.Heartbeat:Connect(function()
		if GameModule.AutoUsePotions.Damage then
			usePotion("AttackDamagePotion1")
		end
		if GameModule.AutoUsePotions.Speed then
			usePotion("MovementSpeedPotion1")
		end
		if GameModule.AutoUsePotions.Health then
			usePotion("HealthPotion1")
		end
		if GameModule.AutoUsePotions.Miner then
			usePotion("MinerPotion1")
		end
		if GameModule.AutoUsePotions.Luck then
			usePotion("LuckPotion1")
		end
	end)
end

function GameModule.stopAutoPotions()
	if PotionConnection then
		PotionConnection:Disconnect()
		PotionConnection = nil
	end
end

-- Cleanup
function GameModule.cleanup()
	IsAutoFarming = false
	IsAutoAttacking = false
	stopMiningMovement()
	stopCombatMovement()
	GameModule.stopAutoPotions()
end

return GameModule
