-- ComboChronicle Vault Teleport Script
-- Main script to be hosted on GitHub

-- Variables
local teleportSpeed = 16 -- Default speed
local groundCheckEnabled = true -- Enable/disable ground checking
local maxDropHeight = 100 -- Maximum height to consider "in air"
local safeZoneTolerance = 15 -- Tolerance for safe zone detection
local groundCheckConnection = nil -- For continuous ground checking
local isCurrentlyTeleporting = false
local currentTween = nil

-- Ground reference points (your provided coordinates)
local groundReferencePoints = {
    Vector3.new(-410.751953, -35.4375076, 59.4064636),
    Vector3.new(-434.66, -8.00, 201.72),
    Vector3.new(-413.12, -7.50, 198.69),
}

-- Services
local Players = game:GetService('Players')
local LocalPlayer = Players.LocalPlayer
local TweenService = game:GetService('TweenService')
local PathfindingService = game:GetService('PathfindingService')
local Workspace = game:GetService('Workspace')
local Plots = Workspace:WaitForChild('Plots')
local RunService = game:GetService('RunService')
local UserInputService = game:GetService('UserInputService')

-- Functions
local function getCharacter()
    if
        LocalPlayer.Character
        and LocalPlayer.Character:FindFirstChild('HumanoidRootPart')
    then
        return LocalPlayer.Character
    end
    return LocalPlayer.CharacterAdded:Wait()
end

local function findPlayerPlot()
    for _, plot in ipairs(Plots:GetChildren()) do
        local sign = plot:FindFirstChild('PlotSign')
        local gui = sign and sign:FindFirstChild('SurfaceGui')
        local frame = gui and gui:FindFirstChild('Frame')
        local label = frame and frame:FindFirstChild('TextLabel')
        if label and label.Text:lower():find(LocalPlayer.Name:lower()) then
            return plot
        end
    end
    return nil
end

-- Check if player is near any of the safe reference points
local function isNearSafeZone(position, tolerance)
    tolerance = tolerance or safeZoneTolerance -- Use global tolerance or default
    
    for _, refPoint in ipairs(groundReferencePoints) do
        local distance = (position - refPoint).Magnitude
        if distance <= tolerance then
            return true, refPoint
        end
    end
    
    return false, nil
end

-- IMPROVED GROUND DETECTION - More tolerant for small height differences
local function isOnGround()
    local character = getCharacter()
    local humanoidRootPart = character and character:FindFirstChild('HumanoidRootPart')
    if not humanoidRootPart then
        return true -- Default to true to avoid unnecessary drops
    end

    local rayOrigin = humanoidRootPart.Position
    local rayDirection = Vector3.new(0, -6, 0) -- Increased to 6 studs for better detection
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

    local rayResult = Workspace:Raycast(rayOrigin, rayDirection, raycastParams)

    -- If we hit something, check if it's close enough to be considered "on ground"
    if rayResult then
        local distanceToGround = rayResult.Distance
        -- Consider "on ground" if within 5 studs (more tolerant)
        return distanceToGround <= 5
    end

    return false
end

-- Check if there's a clear path between two points (no walls)
local function hasLinearPath(startPos, endPos)
    local character = getCharacter()
    if not character then return false end
    
    local direction = (endPos - startPos).Unit
    local distance = (endPos - startPos).Magnitude
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    -- Cast ray from start to end position
    local rayResult = Workspace:Raycast(startPos, direction * distance, raycastParams)
    
    -- If we hit something, there's an obstacle
    return rayResult == nil
end

-- Smart ground detection - only drop if actually floating
local function findGroundBelow(position)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = { getCharacter() }

    local rayDirection = Vector3.new(0, -maxDropHeight, 0)
    local raycastResult = Workspace:Raycast(
        position,
        rayDirection,
        raycastParams
    )

    if raycastResult then
        return raycastResult.Position + Vector3.new(0, 5, 0) -- Add some offset above ground
    end

    -- If no ground found via raycast, use closest reference point
    local closestRefPoint = groundReferencePoints[1]
    local closestDistance = math.huge

    for _, refPoint in ipairs(groundReferencePoints) do
        local distance = (Vector3.new(position.X, 0, position.Z) - Vector3.new(
            refPoint.X,
            0,
            refPoint.Z
        )).Magnitude
        if distance < closestDistance then
            closestDistance = distance
            closestRefPoint = refPoint
        end
    end

    return Vector3.new(position.X, closestRefPoint.Y + 5, position.Z)
end

-- Smart ground checking - only consider off ground if floating AND above reference levels
local function checkAndDropToGround()
    if not groundCheckEnabled then
        return
    end

    local character = getCharacter()
    local hrp = character:FindFirstChild('HumanoidRootPart')
    if not hrp then
        return
    end

    local currentPos = hrp.Position
    
    -- Check if player is near any safe zone - if so, don't drop
    local nearSafeZone, safePoint = isNearSafeZone(currentPos, 15)
    if nearSafeZone then
        return
    end

    -- Use the improved ground detection method
    if isOnGround() then
        return -- Don't drop if standing on something
    end

    -- Find closest reference point to compare height
    local closestRefPoint = groundReferencePoints[1]
    local closestDistance = math.huge

    for _, refPoint in ipairs(groundReferencePoints) do
        local distance = (
            Vector3.new(currentPos.X, 0, currentPos.Z)
            - Vector3.new(refPoint.X, 0, refPoint.Z)
        ).Magnitude
        if distance < closestDistance then
            closestDistance = distance
            closestRefPoint = refPoint
        end
    end

    local heightAboveRef = currentPos.Y - closestRefPoint.Y

    -- Only drop if significantly above reference ground AND not standing on anything AND not in air briefly
    if heightAboveRef > 30 then -- Increased threshold from 20 to 30 studs
        local groundPos = findGroundBelow(currentPos)
        if groundPos then
            local heightDifference = currentPos.Y - groundPos.Y
            local dropDistance = heightDifference
            local dropTime = math.min(dropDistance / 50, 2) -- Max 2 seconds drop time

            local dropCFrame = CFrame.new(groundPos) * (hrp.CFrame - currentPos)
            local dropTween = TweenService:Create(
                hrp,
                TweenInfo.new(
                    dropTime,
                    Enum.EasingStyle.Quad,
                    Enum.EasingDirection.In,
                    0,
                    false,
                    0
                ),
                { CFrame = dropCFrame }
            )

            dropTween:Play()
            dropTween.Completed:Wait()

            -- Small delay to ensure character is stable
            wait(0.5)
        end
    end
end

-- Cancel current tween
local function cancelTween()
    if currentTween then
        currentTween:Cancel()
        currentTween = nil
    end
    
    -- Force stop any teleporting state
    isCurrentlyTeleporting = false
    
    -- Additional safety: anchor the character briefly to stop all movement
    local character = getCharacter()
    local hrp = character and character:FindFirstChild('HumanoidRootPart')
    if hrp then
        hrp.Anchored = true
        wait(0.1)
        hrp.Anchored = false
    end
end

-- IMPROVED PATHFINDING WITH COLLISION DETECTION
local function computePathTo(targetPos)
    local character = getCharacter()
    local hrp = character:FindFirstChild('HumanoidRootPart')
    if not hrp then
        return nil
    end

    -- First check if we can go directly (no obstacles)
    local startPos = hrp.Position
    if hasLinearPath(startPos, targetPos) then
        -- Direct path available, create simple waypoint
        return {{Position = targetPos, Action = Enum.PathWaypointAction.Walk}}
    end

    -- Use pathfinding service with improved settings
    local path = PathfindingService:CreatePath({
        AgentRadius = 3, -- Increased from 2 to avoid walls better
        AgentHeight = 6, -- Increased from 5
        AgentCanJump = true,
        AgentCanClimb = false,
        WaypointSpacing = 8, -- Increased spacing for smoother paths
        Costs = {
            Water = 20,
            DangerousArea = math.huge,
            NonPathableMaterial = math.huge,
            InvisibleWalls = math.huge,
            LaserHitbox = math.huge,
        },
    })

    local success, errorMsg = pcall(function()
        path:ComputeAsync(startPos, targetPos)
    end)

    if not success then
        print("Path computation failed: " .. tostring(errorMsg))
        return nil
    end

    if path.Status == Enum.PathStatus.Success then
        local waypoints = path:GetWaypoints()
        
        -- Filter waypoints to avoid going through walls
        local filteredWaypoints = {}
        local lastValidPos = startPos
        
        for i, waypoint in ipairs(waypoints) do
            if i == 1 then
                -- Always include first waypoint
                table.insert(filteredWaypoints, waypoint)
                lastValidPos = waypoint.Position
            else
                -- Check if we can go directly from last valid position to this waypoint
                if hasLinearPath(lastValidPos, waypoint.Position) then
                    table.insert(filteredWaypoints, waypoint)
                    lastValidPos = waypoint.Position
                else
                    -- Skip this waypoint if it would cause wall clipping
                    print("Skipping waypoint that would clip through walls")
                end
            end
        end
        
        return filteredWaypoints
    else
        print("Pathfinding failed with status: " .. tostring(path.Status))
        return nil
    end
end

-- IMPROVED TELEPORT WITH BETTER COLLISION HANDLING
local function tweenToPath(waypoints, speed)
    local character = getCharacter()
    local hrp = character:FindFirstChild('HumanoidRootPart')
    if not hrp then
        return
    end

    isCurrentlyTeleporting = true

    for i, waypoint in ipairs(waypoints) do
        if not isCurrentlyTeleporting then
            break -- Allow cancellation
        end
        
        local startPos = hrp.Position
        local targetPos = waypoint.Position
        
        -- Add some height to avoid ground clipping
        local adjustedTarget = Vector3.new(targetPos.X, targetPos.Y + 2, targetPos.Z)
        
        -- Double-check for walls before moving
        if not hasLinearPath(startPos, adjustedTarget) then
            print("Obstacle detected, skipping waypoint " .. i)
            continue
        end
        
        local distance = (adjustedTarget - startPos).Magnitude
        local moveTime = distance / speed
        
        local targetCFrame = CFrame.new(adjustedTarget) * (hrp.CFrame - startPos)
        
        currentTween = TweenService:Create(
            hrp,
            TweenInfo.new(
                moveTime,
                Enum.EasingStyle.Linear,
                Enum.EasingDirection.Out,
                0,
                false,
                0
            ),
            { CFrame = targetCFrame }
        )
        
        currentTween:Play()
        currentTween.Completed:Wait()
        
        -- Small pause between waypoints for stability
        wait(0.1)
    end

    isCurrentlyTeleporting = false
    currentTween = nil
    
    -- Final ground check
    checkAndDropToGround()
end

-- TELEPORT TO BASE WITH IMPROVED PATHFINDING
local function teleportToBase()
    local plot = findPlayerPlot()
    if not plot then
        print('Could not find your plot!')
        return
    end

    local purchases = plot:FindFirstChild('Purchases')
    if not purchases then
        print('Could not find Purchases in your plot!')
        return
    end

    local plotBlock = purchases:FindFirstChild('PlotBlock')
    if not plotBlock then
        print('Could not find PlotBlock!')
        return
    end

    local hitbox = plotBlock:FindFirstChild('Hitbox')
    if not hitbox then
        print('Could not find Hitbox!')
        return
    end

    print('Teleporting to base with speed: ' .. teleportSpeed)
    local waypoints = computePathTo(hitbox.Position)
    if waypoints and #waypoints > 0 then
        tweenToPath(waypoints, teleportSpeed)
        print('Teleport completed!')
    else
        print('Could not compute safe path to base!')
    end
end

-- Export functions and variables for GUI access
local TeleportModule = {}
TeleportModule.teleportSpeed = teleportSpeed
TeleportModule.setTeleportSpeed = function(speed)
    teleportSpeed = speed
end
TeleportModule.teleportToBase = teleportToBase
TeleportModule.checkAndDropToGround = checkAndDropToGround
TeleportModule.cancelTween = cancelTween

return TeleportModule
